#Copyright (c) 2013, Shankar Giri V All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions are met:
#
#Redistributions of source code must retain the above copyright notice, this
#list of conditions and the following disclaimer. Redistributions in binary form
#must reproduce the above copyright notice, this list of conditions and the
#following disclaimer in the documentation and/or other materials provided with
#the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
#PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
#CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
#OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
#OF SUCH DAMAGE.

#!/usr/bin/env python
import sys
import math
import os
import shutil
import copy
import codecs
from shapely.geometry import LinearRing, LineString, Point, MultiPoint, Polygon, MultiPolygon, MultiLineString, GeometryCollection
from shapely.ops import unary_union, cascaded_union
from itertools import combinations
import utm as UTM

class XPAPTDataCreator(object):

    def __init__(self, icao='', osmfile='', centerlines=False, centerlights=False, 
                edgelines=False, edgelights=False, taxiway_width=32, taxiway_type="ASPHALT", 
                apron_type="CONCRETE", apron_perimeterlights=0, apron_floodlights=0,
                ourairportsdata=None, osmdata=None, genpath='.'):
        self.icao=icao
        self.osmfile=osmfile
        self.centerlines=centerlines
        self.centerlights=centerlights
        self.edgelines=edgelines
        self.edgelights=edgelights
        self.taxiway_width = taxiway_width
        self.taxiway_type = taxiway_type
        self.apron_type = apron_type
        self.apron_perimeterlights = apron_perimeterlights
        self.apron_floodlights = apron_floodlights
        self.lepos = 0
        self.hepos = 0
        self.lstRunwayData = []
        print 'Initializing the XPAPTDataCreator...'
        self.OurAirportsData = ourairportsdata
        self.OSMAirportsData = osmdata
        self.hndApt = codecs.open("apt.dat", "wb", "utf-8")
        self.path = unicode(os.path.join(genpath, icao))
        self.mkdir(self.path)
        self.path = unicode(os.path.join(self.path, 'Earth Nav Data'))
        self.mkdir(self.path)
        
        
    def GetSurfaceCode(self, OSMSurface, optionSurface):
        if OSMSurface == '':
            surfaceCode = optionSurface
        else:
            surfaceCode = self.OSMAirportsData.GetSurfaceCode(OSMSurface)
        return surfaceCode
        
    def WriteFileHeader(self):
        if sys.platform == 'darwin':
            plm = 'A'
        else:
            plm = 'I'
        self.hndApt.write("%s\n" % plm)
        self.hndApt.write('1000 - Generated by OSMAirports\n\n')
        
    def WriteAPTHeader(self):
        """Always assumes Land airport, for now. No support for seaplane / helipads yet"""
        elevation_ft = self.OurAirportsData.GetAirportElevationFt()
        icao = self.OurAirportsData.GetAirportICAO()
        name = self.OurAirportsData.GetAirportName()
        str = "1     %s 0 0 %s %s\n" % (elevation_ft, icao, name)
        self.hndApt.write(str)
        
    def FindAccuratePos(self, runway):
        leRunwayNumber = self.OurAirportsData.GetLeRunwayNumber(runway)
        leRunwayPos = self.OurAirportsData.GetLeRunwayPosTuple(runway)
        found, surface, leRunwayPosOSM = self.OSMAirportsData.GetRunwayPos(leRunwayNumber)
        heRunwayNumber = self.OurAirportsData.GetHeRunwayNumber(runway)
        heRunwayPos = self.OurAirportsData.GetHeRunwayPosTuple(runway)
        found, surface, heRunwayPosOSM = self.OSMAirportsData.GetRunwayPos(heRunwayNumber)
        (x1, y1) = leRunwayPos
        (x2, y2) = leRunwayPosOSM
        lePosDistance = self.FindDistance(x1, y1, x2, y2)
        (x2, y2) = heRunwayPosOSM
        hePosDistance = self.FindDistance(x1, y1, x2, y2)
        if lePosDistance > hePosDistance:
            print "OSM Co-ordinates for the runway %s/%s are swapped!\nI will swap them back in apt.dat correctly." % (leRunwayNumber, heRunwayNumber)
            print "Please consider correcting the OSM data."
            return 1
        return 0
        
    def WriteRunwayDefs(self):
        print 'Writing Runway Definitions...'
        for runway in self.OurAirportsData.lstRunways:
            edgeLighting = self.OurAirportsData.GetEdgeLightingCode(runway)
            runwayWidth = self.OurAirportsData.GetRunwayWidth(runway)
            lighted = self.OurAirportsData.IsRunwayLighted(runway)
            leRunwayNumber = self.OurAirportsData.GetLeRunwayNumber(runway)
            found, surface, leRunwayPosOSM = self.OSMAirportsData.GetRunwayPos(leRunwayNumber)
            if found != 1:
                continue
            leDisplacedThresholdFt = self.OurAirportsData.GetLeDisplacementThresholdFt(runway)
            heRunwayNumber = self.OurAirportsData.GetHeRunwayNumber(runway)
            found, surface, heRunwayPosOSM = self.OSMAirportsData.GetRunwayPos(heRunwayNumber)
            if found != 1:
                continue
            heDisplacedThresholdFt = self.OurAirportsData.GetHeDisplacementThresholdFt(runway)
            shoulderSurface = self.OurAirportsData.GetRunwayShoulderSurface(runway)
            le_rm = self.OurAirportsData.GetLeRunwayMarkingCode(runway)
            he_rm = self.OurAirportsData.GetHeRunwayMarkingCode(runway)
            le_appr_lighting = self.OurAirportsData.GetLeApproachLightingCode(runway)
            he_appr_lighting = self.OurAirportsData.GetHeApproachLightingCode(runway)
            le_reil = self.OurAirportsData.GetLeREILCode(runway)
            he_reil = self.OurAirportsData.GetHeREILCode(runway)
            le_tdz = int(self.OurAirportsData.GetLeTDZCode(runway))
            he_tdz = int(self.OurAirportsData.GetHeTDZCode(runway))
            centerlights = int(self.OurAirportsData.GetRunwayCenterLighting(runway))
            edgelights = int(self.OurAirportsData.GetRunwayEdgeLighting(runway))
            if edgelights == 1: edgelights = 2
            drs = int(self.OurAirportsData.GetRunwayDRS(runway))
            retVal = self.FindAccuratePos(runway)
            if retVal == 1:
                tmp = leRunwayPosOSM
                leRunwayPosOSM = heRunwayPosOSM
                heRunwayPosOSM = tmp
            lelon, lelat = leRunwayPosOSM
            helon, helat = heRunwayPosOSM
            self.lstRunwayData.append(((lelon, lelat), (helon, helat), float(runwayWidth)))
            if self.OSMAirportsData.GetUseItm():
              (lelat, lelon) = UTM.to_latlon(lelon, lelat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
              (helat, helon) = UTM.to_latlon(helon, helat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            
            if surface == '':
               surfaceCode = self.OurAirportsData.GetSurfaceCode(runway)
            else:
                surfaceCode = self.OSMAirportsData.GetSurfaceCode(surface)
            if surfaceCode == 13: #Water runway
                str = "101   %s   1   %s   %.8f %013.8f %s   %.8f %013.8f\n" % \
                      (runwayWidth, leRunwayNumber, lelat, lelon, heRunwayNumber, helat, helon)
            else:
                str = "100   %s   %s   %s 0.25 %s %s %s %s   %.8f %013.8f    %s    0.00 %s  %s %s %s %s   %.8f %013.8f    %s    0.00 %s  %s %s %s\n" % \
                      (runwayWidth, surfaceCode, shoulderSurface, centerlights, edgelights, \
                      drs, leRunwayNumber, lelat, lelon, leDisplacedThresholdFt, le_rm, \
                      le_appr_lighting, le_tdz, le_reil, heRunwayNumber, helat, helon, \
                      heDisplacedThresholdFt, he_rm, he_appr_lighting, he_tdz, he_reil)
            self.hndApt.write(str)
        return 0

    def WriteBeaconDefs(self):
        print 'Writing Beacon Definitions...'
        for lon, lat in self.OSMAirportsData.lstBeacons:
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("18   %.8f %013.8f 1 BCN\n" % (lat, lon))

    def WriteWindsockDefs(self):
        print 'Writing Windsock Definitions...'
        for lon, lat in self.OSMAirportsData.lstWindsocks:
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("19   %.8f %013.8f 1 WS\n" % (lat, lon))

    def FindLength(self, lst):
        length = 0
        if lst:
            x1, y1 = lst[0]
            x2, y2 = lst[-1]
            length = self.FindDistance(x1, y1, x2, y2)
        return length
        
    def FindDistance(self, x1, y1, x2, y2):
        return math.sqrt((x2-x1)**2+(y2-y1)**2)
            
    def FindClosestRunway(self, lon, lat):
        min = 0
        minrunway = None
        for runway in self.OurAirportsData.lstRunways:
            lenum = self.OurAirportsData.GetLeRunwayNumber(runway)
            henum = self.OurAirportsData.GetHeRunwayNumber(runway)
            found, surface, lepos = self.OSMAirportsData.GetRunwayPos(lenum)
            found, surface, hepos = self.OSMAirportsData.GetRunwayPos(henum)
            lon, lat = lepos
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            lepos = (lat, lon)
            lon, lat = hepos
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            hepos = (lat, lon)
            dist = LineString([lepos, hepos]).project(Point(lon, lat))
            if min == 0:
                min = dist
                lenummin = lenum
                henummin = henum
                leposmin = lepos
                heposmin = hepos
                minrunway = runway
            elif min > dist:
                min = dist
                lenummin = lenum
                henummin = henum
                leposmin = lepos
                heposmin = hepos
                minrunway = runway
        if Point(lon, lat).distance(Point(leposmin)) > Point(lon, lat).distance(Point(heposmin)):
            runwayHeading = self.OurAirportsData.GetHeRunwayHeading(minrunway)
            runwayNumber = henummin
        else:
            runwayHeading = self.OurAirportsData.GetLeRunwayHeading(minrunway)
            runwayNumber = lenummin
            
        return (lenummin, henummin, leposmin, heposmin, runwayHeading, runwayNumber, min)        

    def WritePapiDefs(self):
        for lon, lat in self.OSMAirportsData.lstPapi:
            (lenum, henum, lepos, hepos, runwayHeading, runwayNumber, min) = self.FindClosestRunway(lon, lat)
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("21   %.8f %013.8f  2 %.2f   3.00 %s  PAPI\n" % (float(lat), float(lon), float(runwayHeading), runwayNumber))

    def OptimizePolygon(self, area):
        i = 0
        lstArea = []
        lstArea.append(area[0])
        while i+1 < len(area):
            x1, y1 = area[i]
            x2, y2 = area[i+1]
            if self.FindDistance(x1, y1, x2, y2) > 1e-6:
                lstArea.append(area[i+1])
            i = i + 1
        return lstArea
                        
    def WritePavedSurfaceDefs(self):
        print 'Writing Apron Definitions...'
        for pavement in self.OSMAirportsData.lstAprons:
            osmid, name, surface, coords = pavement
            surfaceCode = self.GetSurfaceCode(surface, self.apron_type)
            self.hndApt.write("\n110   %d 0.25  0.00 Apron: %s, OSMID: %s\n" % (surfaceCode, name, osmid))
            if len(coords) > 2:
              lstArea = coords
              area = LinearRing(lstArea)
              if not area.is_ccw:
                  tmparea = area.coords[::-1]
              else:
                  tmparea = list(area.coords)[:]
              if self.apron_perimeterlights == True:
                  lightcode = 102
              else:
                  lightcode = 0
              for lon, lat in tmparea[:-2]:
                  if self.OSMAirportsData.GetUseItm():
                    (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
                  self.hndApt.write("111  %.8f %013.8f %d\n" % (float(lat), float(lon), lightcode))
              lon, lat = tmparea[-2]
              if self.OSMAirportsData.GetUseItm():
                (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
              self.hndApt.write("113  %.8f %013.8f %d\n" % (float(lat), float(lon), lightcode))
        
    def CalcAreaBuffer1(self, centerline, width, itm=False):
        lstlPos = []
        lstrPos = []
        centerline = LineString(centerline)
        offset = abs(width/2/111132.92)
        if itm:
          offset = width/2

        tmp = centerline.parallel_offset(offset, 'left')
        if tmp.type == 'MultiLineString':
            tmp = tmp[0]
        lstlPos = list(tmp.coords[:])
        tmp = centerline.parallel_offset(offset, 'right')
        if tmp.type == 'MultiLineString':
            tmp = tmp[0]
        lstrPos = list(tmp.coords[:])
        lstlPos = self.SnapToApron(lstlPos)
        lstrPos = self.SnapToApron(lstrPos)
        area = Polygon(lstrPos + lstlPos).buffer(0)
        #if area.type == 'MultiPolygon':
        #    area = area[0]
        #area = area.buffer(0)
        #if not area.exterior.is_ccw:
        #    retVal = list(area.exterior.coords)[::-1]
        #else:
        #    retVal = list(area.exterior.coords)
        return area

    def CalcAreaBuffer(self, centerline, width, itm=False):
        lstPos = []
        centerline = LineString(centerline)
        offset = abs(width/2/111132.92)
        if itm:
          offset = width/2
        area = LinearRing(centerline.buffer(offset, 3).exterior.coords)
        if not area.is_ccw:
            retVal = list(area.coords)[::-1]
        else:
            retVal = list(area.coords)
        return copy.deepcopy(retVal)

    def SnapToRunway(self, lst):
        for pt in lst:
            for runway in self.OSMAirportsData.lstRunways:
                tmp, dRunway = runway
                pos1 = dRunway['le_pos']
                pos2 = dRunway['he_pos']
                lsCoords = LineString([pos1, pos2])
                dist = lsCoords.project(Point(pt))
                ptEndnode = lsCoords.interpolate(dist)
                x, y = pt
                x1, y1 = ptEndnode.x, ptEndnode.y
                dist1 = self.FindDistance(x,y,x1,y1)
                if dist1 < 2e-4:
                    if pt in lst:
                        lst[lst.index(pt)] = (x1, y1)
        return lst

    def SnapToApron(self, lst):
        if len(lst) < 2: return lst
        for pt in [lst[0], lst[-1]]:
            for aprons in self.OSMAirportsData.lstAprons:
                osmid, name, surface, coords = aprons
                if len(coords) > 1:
                  lsCoords = LineString(coords)
                  dist = lsCoords.project(Point(pt))
                  ptEndnode = lsCoords.interpolate(dist)
                  x, y = pt
                  x1, y1 = ptEndnode.x, ptEndnode.y
                  dist1 = self.FindDistance(x,y,x1,y1)
                  if dist1 < 1e-4:
                      lst[lst.index(pt)] = (x1, y1)
                      pt = (x1, y1)
        return lst

    def FindLength(self, coords):
        x1, y1 = coords[0]
        x2, y2 = coords[-1]
        dist = self.FindDistance(x1, y1, x2, y2)
        return dist

    def WriteTaxiwaySurfaceDefs(self):
        print 'Writing Taxiway Definitions...'
        lstAreaStore = []
        lstRunwayP = []
        lstApronP = []
        tmpArea = Polygon()
        tmpArea1 = []
        tmpArea2 = []
        lstsorted = sorted(self.OSMAirportsData.lstTaxiways, key=lambda x: x[3], reverse=True)
        for taxiways in lstsorted:
             osmid, name, surface, dist, coords = taxiways
             if len(coords) < 2: continue
             Area = self.CalcAreaBuffer1(coords, self.taxiway_width, itm=True)
             lstAreaStore.append(Area)
        for lepos, hepos, width in self.lstRunwayData:
            poly1 = self.CalcAreaBuffer1([lepos, hepos], width, itm=True)
            lstRunwayP.append(poly1)
        for osmid, name, surface, coords2 in self.OSMAirportsData.lstAprons:
            lstApronP.append(Polygon(coords2).buffer(0))
        inter = cascaded_union([pair[0].intersection(pair[1]) for pair in combinations(lstAreaStore, 2)]).buffer(0)
        nonoverlap = (cascaded_union(lstAreaStore).buffer(0).difference(inter).buffer(0))
        interr = cascaded_union([x for x in lstRunwayP]).buffer(0)
        intera = cascaded_union([x for x in lstApronP]).buffer(0)
        inter = cascaded_union([inter, interr, intera]).buffer(0)
        nonoverlap = cascaded_union(nonoverlap).buffer(0).difference(inter).buffer(0)
        lstholes= []
        lstedges = []
        for hole in inter:
            if type(hole) is MultiPolygon:
                hole = cascaded_union(hole)[0]
            lstholes.append(hole.buffer(0))
        for area2 in nonoverlap:
            if type(area2) is MultiPolygon:
                area2 = cascaded_union(area2)[0]
            area2 = area2.buffer(0)
            inter1 = cascaded_union(lstholes).intersection(area2)
            if type(inter1) is MultiLineString:
                for a in inter1:
                    lstedges.append(a)
            elif type(inter1) is GeometryCollection:
                for item in inter1:
                    if type(item) is MultiLineString:
                        lstedges.append([a[0] for a in item if type(a) is LineString])
                    elif type(item) is Polygon:
                        tmp = item.buffer(0).exterior.coords[:]
                        for index, edge in enumerate(tmp[:-1]):
                            lstedges.append(LineString([tmp[index], tmp[index+1]]))
                        lstedges.append(LineString([tmp[-1], tmp[0]]))
                    elif type(item) is LineString:
                        lstedges.append(item)
            elif type(inter1) is LineString:
                lstedges.append(inter1)
            elif type(inter1) is MultiPoint:
                lstedges.append(LineString(inter1))
        for area2 in nonoverlap:
            lstindices = []
            if type(area2) is MultiPolygon:
                area2 = cascaded_union(area2)[0]
            area2 = area2.buffer(0)
            if not area2.exterior.is_ccw:
                curAreaCoords = area2.exterior.coords[::-1]
            else:
                curAreaCoords = area2.exterior.coords[:]
            tmpArea = curAreaCoords
            surfaceCode = self.GetSurfaceCode(surface, self.taxiway_type)
            for index, coords in enumerate(tmpArea[:-1]):
                for edge in lstedges:
                    ls = LineString([tmpArea[index], tmpArea[index+1]])
                    if (ls.almost_equals(edge)):
                        lstindices.append(index)
            self.hndApt.write('\n110   %d 0.25  0.00 Taxiway\n' % (surfaceCode))
            for index, (lon, lat) in enumerate(tmpArea[:-1]):
                if index in lstindices:
                    linecode = 0
                    lightcode = 0
                else:
                    linecode = 3
                    lightcode = 102
                if self.edgelights == False:
                    lightcode = 0
                if self.edgelines == False:
                    linecode = 0
                if self.OSMAirportsData.GetUseItm():
                  (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
                self.hndApt.write("111  %.8f %013.8f %d %d\n" % (float(lat), float(lon), linecode, lightcode))
            (lon, lat) = tmpArea[-1]
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("113  %.8f %013.8f\n" % (float(lat), float(lon)))
            #Draw holes
        for hole in lstholes:
            # for poly in lstRunwayP:
#                 if hole.intersects(poly):
#                     hole = hole.difference(poly).buffer(0)
#             for poly in lstApronP:
#                 if hole.intersects(poly):
#                     hole = hole.difference(poly).buffer(0)
            if type(hole) is MultiPolygon:
                hole = cascaded_union(hole)[0]
            #hole = hole.buffer(0)
            skip = 0
            if type(hole) is Polygon:
                if not hole.exterior: break
                for poly in lstApronP:
                    if poly.intersects(hole):
                        skip = 1
                        break
                if skip == 1: continue
                if not hole.exterior.is_ccw:
                    curHoleCoords = hole.exterior.coords[::-1]
                else:
                    curHoleCoords = hole.exterior.coords[:]
            else:
                continue
            if len(curHoleCoords) < 2: continue
            self.hndApt.write('\n110   %d 0.25  0.00 Taxiway Hole Filling\n' % (surfaceCode))
            for (lon, lat) in curHoleCoords[:-1]:
                if self.OSMAirportsData.GetUseItm():
                    (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
                self.hndApt.write("111  %.8f %013.8f\n" % (float(lat), float(lon)))
            (lon, lat) = curHoleCoords[-1]
            if self.OSMAirportsData.GetUseItm():
                (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("113  %.8f %013.8f\n" % (float(lat), float(lon)))    
        
    def WriteTransparentSurfaceDefs(self):
        lstTransparent = []
        for taxiways in self.lstEdgeLines:
            coords = taxiways
            dist = self.FindLength(coords)
            if dist < 5e-3:
                lstArea = self.CalcAreaBuffer(coords, 8)
                surfaceCode = 15
                self.hndApt.write('\n110   15 0.25  0.00 Transparent: xxx\n')
                for lon, lat in lstArea[:-1]:
                       if self.OSMAirportsData.GetUseItm():
                         (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
                       self.hndApt.write("111  %.8f %013.8f\n" % (float(lat), float(lon)))
                (lon, lat) = lstArea[-1]
                if self.OSMAirportsData.GetUseItm():
                  (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
                self.hndApt.write("113  %.8f %013.8f\n" % (float(lat), float(lon)))


    def WriteServiceRoadDefs(self):
        print 'Writing service road Definitions...'
        for roads in self.OSMAirportsData.lstServiceRoads:
            osmid, name, surface, coords = roads
            lstArea = self.CalcAreaBuffer1(coords, 8, itm=True)
            if type(lstArea) is MultiPolygon:
                lstArea = lstArea[0]
            if not lstArea.exterior.is_ccw:
                lstArea = lstArea.exterior.coords[::-1]
            else:
                lstArea = lstArea.exterior.coords[:]
            surfaceCode = self.GetSurfaceCode(surface, self.taxiway_type)
            self.hndApt.write('\n110   %d 0.25  0.00 Service Road: %s, OSM ID: %s\n' % (surfaceCode, name, osmid))
            for lon, lat in lstArea[:-1]:
                   if self.OSMAirportsData.GetUseItm():
                     (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
                   self.hndApt.write("111  %.8f %013.8f\n" % (float(lat), float(lon)))
            (lon, lat) = lstArea[-1]
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("113  %.8f %013.8f\n" % (float(lat), float(lon)))
            
    def WriteServiceRoadCenterLineDefs(self):
        print 'Writing service road centerline Definitions...'
        for roads in self.OSMAirportsData.lstServiceRoads:
            osmid, name, surface, coords = roads
            self.hndApt.write('\n120 Service Road Centerline: %s, OSM ID: %s\n' % (name, osmid))
            for lon, lat in coords[:-1]:
                   if self.OSMAirportsData.GetUseItm():
                     (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
                   self.hndApt.write("111  %.8f %013.8f 22\n" % (float(lat), float(lon)))
            (lon, lat) = coords[-1]
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("115  %.8f %013.8f\n" % (float(lat), float(lon)))

    def WriteTaxiwayCenterLineDefs(self):
        print 'Writing Taxiway centerline Definitions...'
        if self.centerlights == True:
            lightcode = 101
        else:
            lightcode = 0
        for taxiways in self.OSMAirportsData.lstTaxiways:
            osmid, name, surface, dist, coords = taxiways
            self.hndApt.write('\n120 Taxiway Center-Line: %s, OSMID: %s\n' % (name, osmid))
            for lon, lat in coords[:-1]:
                if self.OSMAirportsData.GetUseItm():
                  (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
                self.hndApt.write("111  %.8f %013.8f 1 %d\n" % (float(lat), float(lon), lightcode))
            (lon, lat) = coords[-1]
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("115  %.8f %013.8f\n" % (float(lat), float(lon)))


    def WriteHoldingPositionLineDefs(self):
        print 'Writing Holding position line Definitions...'
        for holding in self.OSMAirportsData.lstHoldings:
            coords = holding
            lon, lat = coords[0]
            if self.OSMAirportsData.GetUseItm():
                (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            (lenum, henum, lepos, hepos, runwayHeading, runwayNumber, dist) = self.FindClosestRunway(lon, lat)
            lon, lat = coords[-1]
            if self.OSMAirportsData.GetUseItm():
                (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            (lenum, henum, lepos, hepos, runwayHeading, runwayNumber, dist1) = self.FindClosestRunway(lon, lat)
            dist = min([dist, dist1])
            if (dist < 0.028):
                linecode = 4
                lightcode = 104
            else:
                linecode = 5
                lightcode = 103
            self.hndApt.write('\n120 Holding Line: %s/%s, %d\n' % (lenum, henum, dist))
            for lon, lat in coords[:-1]:
                if self.OSMAirportsData.GetUseItm():
                    (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
                self.hndApt.write("111  %.8f %013.8f %d %d\n" % (float(lat), float(lon), linecode, lightcode))
            (lon, lat) = coords[-1]
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("115  %.8f %013.8f\n" % (float(lat), float(lon)))
            
    def WriteAirportBoundaryDefs(self):
        print 'Writing Airport Boundary Definitions...'
        if self.OSMAirportsData.lstBoundaries:
            self.hndApt.write('\n130 Airport Boundary\n')
            for lon, lat in self.OSMAirportsData.lstBoundaries[:-2]:
               if self.OSMAirportsData.GetUseItm():
                 (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
               self.hndApt.write("111  %.8f %013.8f\n" % (float(lat), float(lon)))
            (lon, lat) = self.OSMAirportsData.lstBoundaries[-2]
            if self.OSMAirportsData.GetUseItm():
              (lat, lon) = UTM.to_latlon(lon, lat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            self.hndApt.write("113  %.8f %013.8f\n" % (float(lat), float(lon)))
            
    def WriteTaxiStartDefs(self):
        print 'Writing Taxi Start Definitions...'
        for ref, gatepos in self.OSMAirportsData.lstGates:
            distmin = 0
            for terminal in self.OSMAirportsData.lstTerminals:
                i = 0
                while i+1<len(terminal):
                    x1, y1 = terminal[i]
                    x2, y2 = terminal[i+1]
                    dist, pos = self.ShortestDistLineAndPt(terminal[i], terminal[i+1], gatepos)
                    if distmin == 0: 
                        distmin = dist
                        posmin = pos
                    elif distmin > dist: 
                        distmin = dist
                        posmin = pos
                    i = i + 1
            gatelon, gatelat = gatepos
            termlon, termlat = posmin
            brng = self.Bearing(posmin, gatepos)
            if self.OSMAirportsData.GetUseItm():
                lat, lon = UTM.to_latlon(termlon, termlat, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            rEarth = 6371.01 # Earth's average radius in km
            epsilon = 0.000001 # threshold for floating-point equality
            rlat1 = math.radians(lat)
            rlon1 = math.radians(lon)
            rbearing = math.radians((brng)%360)
            rlatdistance = 0.02 / rEarth # normalize linear distance to radian angle
            rlondistance = 0.02 / rEarth # normalize linear distance to radian angle

            rlat = math.asin( math.sin(rlat1) * math.cos(rlatdistance) + math.cos(rlat1) * math.sin(rlatdistance) * math.cos(rbearing) )

            if math.cos(rlat) == 0 or abs(math.cos(rlat)) < epsilon: # Endpoint a pole
                rlon=rlon1
            else:
                rlon = rlon1 + math.atan2(math.sin(rbearing) * math.sin(rlondistance) * math.cos(rlat1), math.cos(rlondistance) - math.sin(rlat1) * math.sin(rlat))
            lat = math.degrees(rlat)
            lon = math.degrees(rlon)
            self.hndApt.write("1300 %.8f %013.8f %f gate all %s\n" % (float(lat), float(lon), float((brng)%360.0), ref))

    def WriteFreqDefs(self):
        print 'Writing Frequency Definitions...'
        for freq in self.OurAirportsData.lstAirportFreqs:
            if (freq['type'] == 'ASOS') or (freq['type'] == 'ATIS'):
                freq_code = 50
            elif (freq['type'] == 'CTAF') or (freq['type'] == 'UNIC'):
                freq_code = 51
            elif (freq['type'] == 'CLD') or (freq['type'] == 'GCCD'):
                freq_code = 52
            elif (freq['type'] == 'GND'):
                freq_code = 53
            elif freq['type'] == 'TWR':
                freq_code = 54
            elif (freq['type'] == 'APP') or (freq['type'] == 'A/D'):
                freq_code = 55
            elif (freq['type'] == 'DEP'):
                freq_code = 56
            else:
                freq_code = 51
         
            self.hndApt.write("%d %d %s\n" % (freq_code, int(float(freq['frequency_mhz'])*100), freq['description']))

    def Bearing(self, P1,P2):
        lon1, lat1 = P1
        lon2, lat2 = P2
        if self.OSMAirportsData.GetUseItm():
            (lat1, lon1) = UTM.to_latlon(lon1, lat1, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
            (lat2, lon2) = UTM.to_latlon(lon2, lat2, self.OSMAirportsData.GetZones()[0][0], self.OSMAirportsData.GetZones()[0][1])
        lat1 = math.radians(lat1)
        lon1 = math.radians(lon1)
        lat2 = math.radians(lat2)
        lon2 = math.radians(lon2)
        dlat = lat2-lat1
        dlon = lon2-lon1
        bearing = math.atan2( (math.sin(dlon)*math.cos(lat2)) , (math.cos(lat1)*math.sin(lat2) - math.sin(lat1)*math.cos(lat2)*math.cos(dlon)) )
        bearing = math.degrees(bearing)
        if bearing < 0: bearing = bearing + 360
        return (bearing)

    def ShortestDistLineAndPt(self, Pt1, Pt2, Pt3):
        x1, y1 = Pt1
        x2, y2 = Pt2
        x3, y3 = Pt3
        dx = float(x2-x1)
        dy = float(y2-y1)
        length = dx*dx + dy*dy
        unit_vector = ((x3 - x1) * dx + (y3 - y1) * dy) / length
        if unit_vector > 1:
            unit_vector = 1
        elif unit_vector < 0:
            unit_vector = 0
        x = x1 + unit_vector * dx
        y = y1 + unit_vector * dy
        distx = x - x3
        disty = y - y3
        dist = math.sqrt(distx*distx + disty*disty)
        return (dist, (x, y))
    def mkdir(self, path):
        print 'Creating %s folder' % path
        try: 
            os.makedirs(path)
        except OSError:
            if not os.path.isdir(path):
                raise
                print 'Failed!!!'
                sys.exit(0)
                
    def close(self):
        self.hndApt.write('99\n')
        self.hndApt.close()
        shutil.copy(u'apt.dat', self.path)
        print 'XPAPTDataCreator Copy type', type(self.path)
